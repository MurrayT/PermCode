package permlab;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.NoSuchElementException;
import static permlab.PermUtilities.SAFE;
import static permlab.PermUtilities.rightExtensions;
import permlab.processor.PermCollector;
import permlab.processor.PermProcessor;
import permlab.property.AvoidsFromRight;
import permlab.property.HereditaryProperty;
import permlab.property.HereditaryPropertyAdapter;
import permlab.property.PermProperty;
import permlab.property.SynchronizedHereditaryProperty;
import permlab.property.Universal;
import permlab.utilities.InvolutionUtilities;

/**
 * Represents a permutation class as specified by a basis.
 *
 * @author Michael Albert
 */
public class PermClass implements PermClassInterface{

    private HashSet<Permutation>[] storedPermutations;
    private Permutation[] basis;
    private AvoidsFromRight[] avoidanceTests;
    HereditaryPropertyAdapter definingProperty = null;
    private long[] RIGHT_MASK;
    private long[] LEFT_MASK;
    private SynchronizedHereditaryProperty syncDefiningProperty;

    /**
     * Constructor that defines a permutation class in terms of a list of basis
     * permutations.
     *
     * @param basis the basis of the class
     */
    public PermClass(Permutation... basis) {
        setupMasks();
        this.basis = basis;
        addAvoidanceTests();
        computeStoredPermutations();
    }
    
    public PermClass(Collection<Permutation> basis) {
        setupMasks();
        this.basis = new Permutation[basis.size()];
        basis.toArray(this.basis);
        addAvoidanceTests();
        computeStoredPermutations();
    }
    
    public PermClass(String... strings) {
        setupMasks();
        this.basis = new Permutation[strings.length];
        int i = 0;
        for(String string: strings) {
            this.basis[i++] = new Permutation(string);
        }
        addAvoidanceTests();
        computeStoredPermutations();
    }
    
    public PermClass(HereditaryPropertyAdapter definingProperty) {
        this.definingProperty = definingProperty;
    }
    
    public PermClassInterface clone() {
        return new PermClass(basis);
    }

    private void setupMasks() {
        RIGHT_MASK = new long[64];
        LEFT_MASK = new long[64];
        RIGHT_MASK[0] = 1L;
        LEFT_MASK[0] = ~0;
        for (int i = 1; i < 64; i++) {
            RIGHT_MASK[i] = (RIGHT_MASK[i - 1] << 1) | 1L;
            LEFT_MASK[i] = LEFT_MASK[i - 1] << 1;
        }

    }

    @SuppressWarnings("unchecked")
    private void computeStoredPermutations() {
        storedPermutations = (HashSet<Permutation>[]) new HashSet[MAXIMUM_STORED_LENGTH + 1];
        storedPermutations[0] = new HashSet<Permutation>();
        storedPermutations[0].add(new Permutation(""));
        for (int n = 1; n <= MAXIMUM_STORED_LENGTH; n++) {
            storedPermutations[n] = new HashSet<Permutation>();
            for (Permutation p : storedPermutations[n - 1]) {
                for (Permutation q : rightExtensions(p)) {
                    if (containsPermutation(q)) {
                        storedPermutations[n].add(q);
                    }
                }
            }
        }
    }

    /**
     * Processes all the permutations in the class of the given length with the
     * supplied {@link PermProcessor processor}.
     *
     * @param length the length of permutations to be processed
     * @param proc the processor
     */
    @Override
    public void processPerms(int length, PermProcessor proc) {
        if (length <= MAXIMUM_STORED_LENGTH) {
            for (Permutation p : storedPermutations[length]) {
                proc.process(p);
            }
            return;
        }
        for (Permutation seed : storedPermutations[MAXIMUM_STORED_LENGTH]) {
            long insertionOptions = RIGHT_MASK[MAXIMUM_STORED_LENGTH];
            //        System.out.println(seed + " " + " o: " + insertionOptions);

            produceChildren(seed, insertionOptions, length, 1, proc);

        }
    }
    
    @Override
    public Collection<Permutation> getPerms(int length) {
        PermCollector collector = new PermCollector();
        processPerms(length, collector);
        return collector.getCollection();
    }

    @Override
    public Collection<Permutation> getPermsTo(int length) {
        PermCollector collector = new PermCollector();
        for(int i = 1; i <= length; i++) {
            processPerms(i, collector);
        }
        return collector.getCollection();
    }

    /*
     * This is the main depth first search. At each call, insertionOptions
     * is a bit list of potential values for a new last element of a permutation
     * in the class extending seed. First, all of these values are checked to
     * see if they really are valid. Those which are, are generated and added
     * as children. Those which are not are recoded.
     * 
     * Next we iterate over the children. The insertion options are updated
     * so that the two value gaps formed by the value added are both marked
     * as allowed, and the remainder are copied (appropriately shifted above)
     * from the known options. As a result, any failure to lie in the class must
     * involve both the new element to add, and the immediately preceding
     * element.
     */
    // TODO Change things so that everything works with arrays until the end
    private void produceChildren(Permutation seed, long insertionOptions,
            int length, int includeFinal, PermProcessor proc) {
        ArrayList<Permutation> children = new ArrayList<Permutation>();
        // Generate the children
        for (int i = 0; i <= seed.elements.length; i++) {
            if (((insertionOptions >> i) & 1L) != 0) {
                int[] es = new int[seed.length() + 1];
                System.arraycopy(seed.elements, 0, es, 0, seed.elements.length);
                es[seed.elements.length] = i;
                for (int k = 0; k < seed.elements.length; k++) {
                    if (es[k] >= i) {
                        es[k]++;
                    }
                }
                Permutation child = new Permutation(es, SAFE);
                if (containsPermutation(child, includeFinal)) {
                    children.add(child);
                } else {
                    insertionOptions &= ~(1L << i);
                }
            }
        }
        // If we are done, process the children
        if (seed.length() == length - 1) {
            for (Permutation p : children) {
                proc.process(p);
            }
            return;
        }
        // Otherwise extend the children as noted above
        int i = -1;
        for (Permutation child : children) {
            i++;
            while (((insertionOptions >> i) & 1L) == 0) {
                i++;
            }
            long newOptions = (insertionOptions & RIGHT_MASK[i]) | ((insertionOptions & LEFT_MASK[i]) << 1);
            produceChildren(child, newOptions, length, 2, proc);
        }

    }

    @Override
    public boolean containsPermutation(Permutation q) {
        for (AvoidsFromRight a : avoidanceTests) {
            if (!a.isSatisfiedBy(q)) {
                return false;
            }
        }
        return true;
    }

    private boolean containsPermutation(Permutation q, int includeFinal) {
        for (AvoidsFromRight a : avoidanceTests) {
            if (!a.isSatisfiedBy(q, includeFinal)) {
                return false;
            }
        }
        return true;
    }

    private void addAvoidanceTests() {
        avoidanceTests = new AvoidsFromRight[basis.length];
        for (int i = 0; i < basis.length; i++) {
            avoidanceTests[i] = new AvoidsFromRight(basis[i]);
        }
    }

    
    
    
     public Iterator<Permutation> getIterator(int low, int high) {

        return getRestrictedIterator(low, high, new Universal());

    }

    public Iterator<Permutation> getRestrictedIterator(int low, int high, PermProperty prop) {

        return new PermClass.PermClassIterator(this.definingProperty, low, high, prop);

    }

    public Iterator<Permutation> getIterator(int n) {

        return getRestrictedIterator(n, new Universal());

    }

    public Iterator<Permutation> getRestrictedIterator(int n, PermProperty prop) {

        return new PermClass.PermClassIterator(this.definingProperty, n, prop);

    }

    public Iterator<Permutation> getSynchronizedIterator(int n) {

        if (syncDefiningProperty == null) {
            syncDefiningProperty = new SynchronizedHereditaryProperty(this.definingProperty);
        }
        return new PermClass.PermClassIterator(syncDefiningProperty, n);

    }

    // TODO: Fix this
//    @Override
//    public PermClassInterface clone() {
//        return this;
//    }

    private static class PermClassIterator implements Iterator<Permutation> {

        Deque<Permutation> stack = new ArrayDeque<Permutation>() {
            {
                add(new Permutation());
            }
        };
        Permutation next = null;
        HereditaryProperty definingProperty;
        int low;
        int high;
        PermProperty extraProperty;

        public PermClassIterator(HereditaryProperty definingProperty, int low, int high, PermProperty extraProperty) {
            this.definingProperty = definingProperty;
            this.low = low;
            this.high = high;
            this.extraProperty = extraProperty;
        }

        public PermClassIterator(HereditaryProperty definingProperty, int n, PermProperty extraProperty) {
            this(definingProperty, n, n, extraProperty);
        }

        public PermClassIterator(HereditaryProperty definingProperty, int n) {
            this(definingProperty, n, n, new Universal());
        }

        @Override
        public boolean hasNext() {

            if (next != null) {
                return true;
            }

            // MA: Needed to eliminate recursion which was blowing stack
            while (true) {

                if (stack.isEmpty()) {
                    return false;
                }

                Permutation candidate = stack.pop();

                if (candidate.length() > high) {
                    return false;
                }

                if (candidate.length() < high) {
                    if (!(extraProperty instanceof HereditaryProperty) || 
                            extraProperty.isSatisfiedBy(candidate)) {
                        for (Permutation p : rightExtensions(candidate)) {                  /////////////////////////////////////////////////////////////////
                            if (p.length() <= high /* && containsPermutation(p) */) {
                                stack.push(p);
                            }
                        }
                    }
                }

                if (candidate.length() >= low) {
                    next = candidate;
                    return true;
                }
            }
        }

        @Override
        public Permutation next() {
            if (!hasNext()) {
                throw new NoSuchElementException("No elements remaining in involution class");
            }
            Permutation result = next;
            next = null;
            return result;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException("Remove is not supported.");
        }
    }
}
    
    
    
    
    
    
    
    
    
    
    

